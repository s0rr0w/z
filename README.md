z
=

Z (Zet) Framework - HTML/JS реактор для построения одностраничных приложений

 > -- Программируй UI без использования JS!  
 > -- Это как? o_O

Примеры можно постмотреть тут: http://s0rr0w.github.io/z/examples

Версия: 0.6

---

## Оглавление

* [Введение](#Введение)
* [Подключение](#Подключение)
* [События](#События)
* [Вызов событий](#Вызов-событий)
* [Обработчики](#Обработчики)
* [Темплейтирование](#Темплейтирование)

---

### Введение

Как и любой реактор, данный фреймворк оперирует следующими сущностями: обработчик события (handler), диспатчер (dispatcher) и событие (event). Диспатчер запускает именованое событие, которое потом обрабатывается какими-то обработчикам. На этом построена вся логика фреймворка, и именно на этом принципе строится весь UI. Без MVC, без модулей, без роутеров и без JS кода.

---

### Подключение

Вам потребуется подключить всего два файла:
```html
<script type="text/javascript" src="z.js"></script>
<script type="text/javascript" src="z_handlers.js"></script>
```
Где:
* `z.js` -- код самого фреймворка
* `z_handlers.js` -- код обработчиков, которые используются в вашем проекте (аналог расширений или плагинов в других фреймворках)

---

### События

События Z фреймворка очень похожи на DOM-события, но их распространение в DOM-дереве принципиально отличается. Z-событие распространяется от какого-то контейнера и, при определенных условиях, на определенные элементы внутри. Эта зона видимости указывается непосредственно при запуске события и не зависит от наличия или отсутствия обработчика на каком-либо элементе. 

События бывают двух типов: локальные и глобальные. Локальные события имеют локализацию зоны распространения события определенным контейнером. Глобальные события работают в рамках всего документа, и срабатывают только на элементах, которым добавлены глобальные обработчики. Основное предназначение глобальных событий - рендеринг данных, которые присылаются с сервера, или одновременная модификация распределенных по всему DOM-дереву элементов (аналог data-binding)

Фреймворк не содержит методов остановки распространения событий (stopPropagation), так как на практике эта функциоальность не нужна. Данная "проблема" спокойно решается путем изменения зоны распространения события или дополнительной функцональностью обработчиков. 

#### Структура `zEvent`

```javascript
{
  e: "eventName",
  t: targetNode,
  f: containerNode,
  p: "propagation",
  data: JSON || Object,
  [b: isBroadcastedEvent,]
  [use: "dispatcherID"]
}
```
Где: 
* `e` -- имя события  
* `t` -- ссылка на элемент, который был __инициатором__ события  
* `f` -- ссылка на элемент, с которого начнется распространяться событие  
* `p` -- директивы распространения события  
* `data` -- данные, которые передаются вместе с событием  
* `b` -- признак того, что событие было переадресовано дочерним элементам  
* `use` -- ссылка на реальный диспатчер события  

---

### Вызов событий

Процесс запуска событий несколько отличается от того, что существует в браузере или других фреймворках. Существует два раздельных процесса: инициализация (описание) диспатчеров и непосредственно запуск события. Запуск z-события делается или по событиям браузера, или в процессе темплейтинга с помощью директивы `<exec>`. 

Диспатчеры описывают правила запуска события и бывают двух типов: абсолютные и относительные. Абсолютные диспатчеры непосредственно формируют объект `zEvent`, в то время как относительные используют ссылку на другой диспатчер

Для инициализации диспатчеров используются следующие директивы: 

* Абсолютная директива `<dispatch>` [»»»](#Абсолютная-директива-dispatch)
* Относительная директива `<dispatch>` [»»»](#Относительная-директива-dispatch)

Запуск событий через HTML директивы осуществляется с помощью:

1. Директивы `<handler>` [»»»](#Директива-handler)
2. Директивы `<exec>` [»»»](#Директива-exec)
 
Также можно использовать JS API для запуска событий:

1. JS-метод `z.dispatch()` [»»»](#js-метод-zdispatch)
2. JS-метод `z.dispatchById()` [»»»](#js-метод-zdispatchbyid)

[Интерактивный пример](http://s0rr0w.github.io/z/examples/6/) наглядно продемонстрирует логику работы диспатчера событий.

#### Абсолютная директива `<dispatch>`

Данная директива носит __описательный__ характер и __не запускает__ событие. Реальным инициатором запуска могут быть директивы `<exec/>` или `<handler/>`, которые будут описаны ниже.

##### Формат

```html
<dispatch e="eventName" [f="cotainerNode"] [p="propagation"] [id="dispatchID"] [name="dispatchName"]>[{ JSON Object }]</dispatch>
```
Где: 
* `e` -- имя события  
* `f` -- контейнер, с которого начинать распространение события  
* `p` -- директивы распространения события  
* `id` -- идентификатор диспатчера
* `name` -- имя диспатчера
* `{ JSON Object }` -- объект с данными, который будет путешествовать вместе с событием

Атрибуты `f`, `p`, `id`, `name` и содержимое ноды `{ JSON Object }` являются не обязательными

###### Имя события `e[vent]`

Имя события должно удовлетворять правилам именования переменных JS, значения атрибутов и названию тегов.

_Примеры названий_
```
click, myCoolEvent2, Do_It_Again
```

###### Контейнер распространения события `f[rom]`

Параметр может принимать следующие значения:

* `.` -- родительский элемент тега `<dispatch>`
* `#id` -- идентификатор ноды  
* `.className` -- имя класса первого из вышестоящих родительских элементов  
* `tagName` -- имя первого из вышестоящих элементов

По умолчанию, если параметр не задан, в качестве контейнера будет взят родительский элемент тега `<dispatch>`

Для __глобальных__ событий данный параметр __игнорируется__

_Например_
```html
<body>
  <header class="superClass">
    <div class="superClass">
      <dispatch e="e1" f="#pageFooter"></dispatch>
      <dispatch e="e2" f=".superClass"></dispatch>
      <dispatch e="e3" f="header"></dispatch>
      <dispatch e="e4"></dispatch>
    </div>
  </header>
  <footer id="pageFooter">
  </footer>
</body>
```

Событие `e1` начнет свое распространение с `footer#pageFooter`, события `e2` и `e4` с `div.superClass` (первый родительский элемент, который удовлетворяет условиям), а событие `e3` с тега `header`

###### Директивы распространения события `p[ropagation]`

Доступны следующие варианты директив:

* `global` -- событие является глобальным, распространяется только среди елементов с глобальными обработчиками
* `parent` -- распространяется исключительно на контейнере, описанном в атрибуте `f`
* `childNodes` -- распространяется на прямых потомках контейнера
* `nodeName` -- на дочерних элементах с данным именем тега
* `.className` -- на дочерних элементах с данным классом
 
По умолчанию событие распространяется на все элементы внутри контейнера, в том числе и на те, которые были только что созданы при помощи темплейт системы. Это может быть причиной деградации скорости работы. 
 
Директивы `global` и `parent` являются исключительными и их использование допускается только в единичном виде. Все остальные директивы можно записывать через запятую. 

Зона распространения события для неглобальных событий всегда идет в следующем порядке: сначала событие отправляется родительскому контейнеру, а потом уже тем элементам, которые указаны в списке директив. Элементы перебираются вне зависимости от того, есть там обработчик, или нет.

__Важно!__ При том, что директивы перебираются в прямом порядке (в том, в котором они указаны в списке), сами элементы перебираются __в обратном__!

_Например_
```html
<body>
  <dispatch e="e1" p="global"></dispatch>
  <dispatch e="e2" p="parent"></dispatch>
  <dispatch e="e3" p="childNodes,span"></dispatch>
  <dispatch e="e4" p="li,span,.newItem"></dispatch>
  <ul>
    <li>Item <span>1</span></li>
    <li>Item <span>2</span></li>
    <li class="newItem">Item <span>3</span></li>
  </ul>
</body>
```

Событие `e1` глобальное, а так как мы не зарегистрировали ни одного соответствующего обработчика, то событие не будет распространяться ни на один из тегов.

В зону видимости события `e2` попадет только тег `body`.  

У события `e3` зона распространения будет следующая:
* `body` как родительский контейнер диспатчера
* `ul` как дочерний элемент (`childNodes`) контейнера
* 3 тега `span`

У события `e4` зона распространения события будет следующая:
* `body` как родительский контейнер диспатчера
* 3 тега `li`
* 3 тега `span`
* `li.newItem` повторно попадает в зону видимости

###### Именование диспатчеров по `id` и `name`

Директивам `<dispatch>` могут быть присвоены абсолютное имя `id` или относительное `name`, значения которых должны удовлетворять стандартным требованиям к именованию тегов.

###### Объект с данными

Содержимое тега `<dispatch>` сначала интерпретируется с помощью встроенной темплейт системы, а уже потом результат в виде текстового содержимого парсится как JSON-объект. 

Допускается пустое значение тега `<dispatch>`, в данном случае у события поле `data` будет равно пустому JSON-объекту.

_Пример использования_
```html
<dispatch e="e1">{ "x": 1 }</dispatch>
<dispatch e="e2">{ "x": <value>someX</value> }</dispatch>
```

Событие `e1` будет содержать поле `data`, равное JSON-объекту `{ "x": 1 }`, а событие `e2` - результат замещения тега `<value>` на значение переменной `someX`, а потом уже получившемуся JSON-объекту.

#### Относительная директива `<dispatch>`

Данная инструкция позволяет использовать удаленный диспатчер по `id` или по `name`.

##### Формат

```html
<dispatch use="dispatcherID">[{ JSON Object }]</dispatch>
```
Где: 
* `use` -- идентификатор или путь к удаленной ноде `<dispatch>`

###### Идентификатор или путь к удаленному диспатчеру (`use`)

Данный параметр может принимать или `id` удаленного диспатчера, или же путь обращения по имени ноды `name`.

Формат обращения по имени ноды следующий:

```
use="containerSelector/[/]dispatcherName"
```
Где:
* `containerSelector` -- селектор, аналогичный параметру `f` директивы `<dispatch>`
* `dispatcherName` -- имя `name` диспатчера

Для поиска прямого потомка с необходимым именем используется один `/`, на любом уровне вложенности - `//` (по аналогии с XPath). Если контейнер содержит больше одного диспатчера с одинаковым именем, будет вызван первый попавшийся.

_Пример использования_
```html
<div class="container">
 <!-- D1 -->
 <dispatch e="e1" id="farDispatcher1" name="localName"></dispatch>
 <span>
  <!-- D2 -->
  <dispatch e="e1" name="localName"></dispatch>
  <exec>
   <!-- 1 --><dispatch use="farDispatcher1"></dispatch>
   <!-- 2 --><dispatch use="./localName"></dispatch>
   <!-- 3 --><dispatch use="div/localName"></dispatch>
   <!-- 4 --><dispatch use=".container/localName"></dispatch>
  </exec>
 </span>
</div>
```

1. Будет вызван `D1` по `id` `#farDispatcher1`
2. Будет вызван `D2`, так как контейнер для вызывающего диспатчера является `span`, в нем уже ищется диспатчер с `name="localName"`
3. Будет вызван `D1`, так как указан контейнер `div`, но первый попавшийся диспатчер с именем `localName` скорее всего будет именно он
4. Будет вызван `D1`, аналогично 3

###### Объект с данными

Если JSON-объект определен, то событие будет запущено именно с этим объектом. Фактически, мы переопределяем данные удаленного диспатчера. Если JSON-объект не определен, то будут использованы данные вызываемого диспатчера.

_Например_
```html
<dispatch e="e1" id="farDispatcher1">{ "x": 1 }</dispatch>
<dispatch e="e2" id="farDispatcher2"></dispatch>

<exec>
<!-- 1 --><dispatch use="farDispatcher1">{ "x": 2, "y": 3 }</dispatch>
<!-- 2 --><dispatch use="farDispatcher1"></dispatch>

<!-- 3 --><dispatch use="farDispatcher2">{ "x": 2, "y": 3 }</dispatch>
<!-- 4 --><dispatch use="farDispatcher2"></dispatch>
</exec>
```

1. Будет вызван `dispatch#farDispatcher1`, который запустит событие `e1`, которое будет содержать данные `{ "x": 2, "y": 3 }`
2. Будет вызван тот же диспатчер, но данные будут те, которые определены первоначально: `{ "x": 1 }`
3. Результат будет аналогичный пункту 1, только с другим именем события
4. Данные события `e2` будут пустыми (`{}`)

#### Директива `<handler>`

Данная директива навешивает DOM-обработчик определенного DOM-события на родительскую ноду.

__Важно!__ В случае успешного срабатывания обработчика, у DOM-события вызываются два метода: `stopPropagation()` и `preventDefault()`

##### Формат

```html
<handler on="DOMEventName" [target="target"] [keys="keyList"] [confirm="confirmMessage"] [freeze="seconds"]>
 <dispatch />
 ...
</handler>
```
Где: 
* `on` -- имя DOM-события
* `target` -- контейнер, на который будет навешен обработчик
* `keys` -- список допустимых клавиш  
* `confirm` -- текст для подтверждения действия
* `freeze` -- время блокировки повторного срабатывания

Атрибуты `target`, `keys`, `confirm` и `freeze` являются не обязательными

###### Имя DOM-события `on`

Имя DOM-события должно удовлетворять правилам именования событий функции addEventListener.

_Примеры названий_
```
click, keypress, scroll
```

###### Контейнер `target`

По умолчанию обработчик DOM-события навешивается на ноду, которая содержит `<handler>`, однако допускается вариант навешивания DOM-события на `window`, для этого нужно указать атрибут `target="window"`

_Примеры использования_
```html
<a href="#">
 <handler on="click">
  <dispatch e="clickOnLink" f="BODY" p=".box"></dispatch>
  <dispatch use="openModal"></dispatch>
 </handler>
 <handler on="scroll" target="window">
  <dispatch e="globalScroll" p="global"></dispatch>
 </handler>
</a>
```

При всем при том, что оба обработчика находятся внутри тега `<a>`, первый `<handler>` добавит обработчик DOM-события `click` своему родителю `<a>`, а второй обработчик DOM-события `scroll` будет добавлен `window`.

Если пользователь нажмет на данную ссылку, то будут запущены два события: `clickOnLink`, которое начнет свое распространение с `<body>` для всех элементов с классом `.box`, и удаленное абсолютное событие с `id="openModal"`

Если пользователь использует прокрутку, то будет запущено глобальное событие `globalScroll`.

###### Список допустимых клавиш `keys`

Если указан этот параметр, то события будут запускаться только в случае совпадения с указанным списком клавиш. Список формируется из определенных констант, разделенных запятой.

Допускаются следующие значения:

*	`DEL` (46) -- кнопка `Del`
* `BS` (8) -- кнопка `Backspace`
* `ENTER` (13) -- кнопка `Enter`
* `ESC` (27) -- кнопка `Esc`
* `TAB` (9) -- кнопка `Tab`
* `INS` (45) -- кнопка `Ins`
* `LA` (37) -- кнопка управления курсором `Left Arrow`
* `UA` (38) -- кнопка управления курсором  `Up Arrow`
* `RA` (39) -- кнопка управления курсором  `Right Arrow`
* `DA` (40) -- кнопка управления курсором  `Down Arrow`

_Пример использования_
```html
<a href="#">
 <handler on="keypress" keys="BS,DEL">
  <dispatch e="removeItem" f=".item" p="parent"></dispatch>
 </handler>
</a>
```

Если на данной ссылке нажать кнопку `Del` или `Backspace`, то будет запущено событие `removeItem`. В противном случае запуск события не производится.

###### Подтверждение действия `confirm`

Если необходимо подтверждение действия со стороны пользователя, то использование данной директивы вызовет стандартный JS-метод `confirm()` перед запуском события. В качестве параметра JS-метода будет передано содержимое атрибута `confirm`. Если пользователь подтвердит выбор, то события будут запущены. В противном случае запуск не производится. 

_Пример использования_
```html
<a href="#">
 <handler on="keypress" keys="BS,DEL" confirm="Вы уверены, что хотите удалить данный элемент?">
  <dispatch e="removeItem" f=".item" p="parent"></dispatch>
 </handler>
</a>
```

В данном примере запуск события удаления будет производиться и с ограничением нажимаемых клавиш, и с обязательным подтверждением со стороны пользователя.

###### Время блокировки повторного срабатывания `freeze`

Данная директива позволяет блокировать на определенное количество секунд повторное срабатывание запуска обработчика события.

_Пример использования_
```html
<button>
 <handler on="click" freeze="5">
  <dispatch e="sendData" p="global"></dispatch>
 </handler>
</button>
```

После нажатия на кнопку будет запущено глобальное событие `sendData`, и в течение 5 секунд будет заблокирована возможность повторного запуска данного события.

#### JS-метод `z.dispatch()`

Данный метод позволяет запускать события [zEvent](#Структура-zevent)

##### Формат

```javascript
z.dispatch(zEvent[,zEvent,...]);
```

_Пример использования_
```javascript
z.dispatch(
 {
  e: "e1", 
  f: document.getElementById("container"),
  p: "childNodes",
  data: { "x": 1 }
 },
 {
  e: "e2",
  p: "global"
 }
)
```

#### JS-метод `z.dispatchById()`

Данный метод является аналогом удаленного вызова директивы `<dispatch>`, за исключением того, что данные не замещаются, а __добавляются__ к существующим.

##### Формат

```javascript
z.dispatchById( "dispatcherID"[, mixinData ] );
```
Где
* `dispatcherID` -- идентификатор ноды `<dispatch>`
* `mixinData` -- объект данных, который будет __добавлен__ к существующим данным 

---

### Обработчики

Во фреймворке в качестве обработчиков выступают примитивные JavaScript-функции. Следуя идеологии *nix-way, они должны выполнять одну функцию, но делать это наилучшим образом. 

* Установка обработчиков `<e>` [»»»](#Установка-обработчиков-e)
* Регистрация обработчиков `z.addHandler` [»»»](#Регистрация-обработчиков-zaddhandler)
* Предустановленные обработчики [»»»](#Предустановленные-обработчики)

#### Установка обработчиков `<e>`

Данная директива устанавливает обработчик родительской ноде

##### Формат

```html
<e [global] on="eventName" do="handlerAlias">[params]</e>
```
Где: 
* `global` -- признак глобального обработчика
* `on="eventName"` -- имя события, по которому будет срабатывать обработчик
* `do="handlerAlias"` -- имя функции-обработчика, которая будет выполнена
* `params` -- дополнительные параметры, которые будут переданы функции-обработчику, в формате `param1,param2,...,paramN`

Например, мы хотим, чтобы тег `<body>` реагировал на события `setLayout`, добавляя класс `modal`

```html
<body>
  <e on="setLayout" do="addClass">modal</e>
</body>
```

#### Регистрация обработчиков `z.addHandler`

Фреймворк в качестве обработчиков воспринимает только те функции, которые были предварительно зарегистрированы через интерфейс `z.addHandler`

##### Формат

```javascript
z.addHandler("handlerAlias", function(eventObject,passedParams){});
```
Где: 
* `handlerAlias` -- имя функции-обработчика
* `function` -- ссылка на функцию
* `eventObj` -- объект события `zEvent`
* `passedParams` -- массив дополнительных параметров, которые были указаны для установщика обработчика `<e>`

__Внимание!__ Ключевое слово `this` в функции-обработчике будет ссылаться на ноду, которой был установлен данный обработчик

_Пример использования_
```javascript
z.addHandler("addClass", function(e, data){
 if (data[0]) this.classList.add(data[0]);
});
```
Если обработчики были следующими
```html
<e on="setLayout" do="addClass">modal</e>
<e on="setLayout" do="addClass">myClass</e>
```
то значение `data[0]` для вызова первого обработчика `addClass` будет равно `modal`, а для второго уже `myClass`

#### Предустановленные обработчики

По умолчанию в системе установлены следующие обработчики:

* [template](#Обработчик-template)
* [templateIfMatch](#Обработчик-templateifmatch)
* [templateIfAttrMatch](#Обработчик-templateifattrmatch)
* [templateIfExists](#Обработчик-templateifexists)
* [templateScopeIfExists](#Обработчик-templatescopeifexists)
* [templateOnce](#Обработчик-templateonce)
* [broadcastEvent](#Обработчик-broadcastevent)
* [dispatchEvent](#Обработчик-dispatchevent)

Подробнее о темплейтировании можно прочитать в [соответствующем разделе](#Темплейтирование)

##### Обработчик `template`

```html
<e on="eventName" do="template">templateID[,templatingMode]</e>
```
Где
* `templateID` -- идентификатор темплейта `<template>`
* `templatingMode` -- режим темплейтирования `add` или `replace`

Обработчик выполняется без дополнительных условий срабатывания

_Например_
```html
<div>
 <e on="test" do="template">myTemplate</e>
 <exec>
  <dispatch e="test"></dispatch>
 </exec>
</div>
```

##### Обработчик `templateIfMatch`

```html
<e on="eventName" do="templateIfMatch">propertyName,constant,templateID[,templatingMode]</e>
```
Где
* `propertyName` -- имя свойства объекта `zEvent.data`
* `constant` -- требуемое значение свойства для срабатывания обработчика
* `templateID` -- идентификатор темплейта `<template>`
* `templatingMode` -- режим темплейтирования `add` или `replace`

Обработчик срабатывает, если переданные с событием данные (`zEvent.data`) содержат свойство `propertyName` и оно равняется `constant`. 

_Например_
```html
<div>
 <div>
  <e on="test" do="templateIfMatch">tab,one,myTemplate</e>
  <!-- Этот обработчик будет вызван, так как свойство tab в данных события равно "one" -->
 </div>
 <div>
  <e on="test" do="templateIfMatch">tab,two,myTemplate</e>
  <!-- Этот обработчик не будет выполнен -->
 </div>
 <exec>
  <dispatch e="test">{ "tab": "one" }</dispatch>
 </exec>
</div>
```

##### Обработчик `templateIfAttrMatch`

```html
<e on="eventName" do="templateIfAttrMatch">attributeName,templateID[,templatingMode]</e>
```
Где
* `attributeName` -- имя атрибута и свойства объекта `zEvent.data` 
* `templateID` -- идентификатор темплейта `<template>`
* `templatingMode` -- режим темплейтирования `add` или `replace`

Обработчик срабатывает, если переданные с событием данные (`zEvent.data`) содержат свойство `attributeName` и его значение равняется значению одноименного атрибута ноды. 

_Например_
```html
<div>
 <div tab="one">
  <e on="test" do="templateIfAttrMatch">tab,myTemplate</e>
  <!-- 
   Этот обработчик будет вызван, так как свойство tab в данных события равно значению 
   одноименного атрибута "one" 
  -->
 </div>
 <div tab="two">
  <e on="test" do="templateIfAttrMatch">tab,myTemplate</e>
  <!-- Этот обработчик не будет выполнен -->
 </div>
 <exec>
  <dispatch e="test">{ "tab": "one" }</dispatch>
 </exec>
</div>
```

##### Обработчик `templateIfExists`

```html
<e on="eventName" do="templateIfExists">propertyName,templateID[,templatingMode]</e>
```
Где
* `propertyName` -- имя свойства объекта `zEvent.data` 
* `templateID` -- идентификатор темплейта `<template>`
* `templatingMode` -- режим темплейтирования `add` или `replace`

Обработчик срабатывает, если переданные с событием данные (`zEvent.data`) содержат свойство `attributeName` и его значение строго не равно `undefined`

_Например_
```html
<div>
 <div>
  <e on="test" do="templateIfExists">one,myTemplate</e>
  <!-- Этот обработчик будет вызван, так как свойство one присутствует в данных события -->
 </div>
 <div>
  <e on="test" do="templateIfExists">two,myTemplate</e>
  <!-- Этот обработчик не будет выполнен, данные события не содержат свойства two -->
 </div>
 <div>
  <e on="test" do="templateIfExists">three,myTemplate</e>
  <!-- Этот обработчик также будет вызван, так как свойство three определено -->
 </div>
 <exec>
  <dispatch e="test">{ "one": true, "three": { "x": 10, "y": 20 } }</dispatch>
 </exec>
</div>
```

##### Обработчик `templateScopeIfExists`

```html
<e on="eventName" do="templateScopeIfExists">propertyName,templateID[,templatingMode]</e>
```
Где
* `propertyName` -- имя свойства объекта `zEvent.data` 
* `templateID` -- идентификатор темплейта `<template>`
* `templatingMode` -- режим темплейтирования `add` или `replace`

Обработчик срабатывает, если переданные с событием данные (`zEvent.data`) содержат свойство `attributeName` и его значение строго не равно `undefined`. В темплейт будет передана копия события, у которого данные будут равны копии свойства `zEvent.data[propertyName]`

_Например_
```html
<div>
 <div>
  <e on="test" do="templateScopeIfExists">one,myTemplate</e>
  <!-- Этому темплейту будут переданы данные { "x": 0, "y": 50 } -->
 </div>
 <div>
  <e on="test" do="templateScopeIfExists">two,myTemplate</e>
  <!-- Этому { "x": 10, "y": 20 } -->
 </div>
 <exec>
  <dispatch e="test">{ "one": { "x": 0, "y": 50 }, "two": { "x": 10, "y": 20 } }</dispatch>
 </exec>
</div>
```

##### Обработчик `templateOnce`

```html
<e on="eventName" do="templateOnce">templateID[,templatingMode]</e>
```
Где
* `templateID` -- идентификатор темплейта `<template>`
* `templatingMode` -- режим темплейтирования `add` или `replace`

Обработчик срабатывает один раз 

_Например_
```html
<div>
 <e on="test" do="templateOnce">myTemplate</e>
 <exec>
  <dispatch e="test">{ "color": "red" }</dispatch>
  <!-- Это событие будет обработано -->
  <dispatch e="test">{ "color": "blue" }</dispatch>
  <!-- Это уже нет -->
 </exec>
</div>
```

##### Обработчик `broadcastEvent`

```html
<e on="eventName" do="broadcastEvent">[p1,p2,...,pn]</e>
```
Где
* `p1,p2,...pn` -- директивы распространения события

Данный обработчик создает и запускает копию события с указанными в параметрах обработчика директивами распространения, при этом данные события (`zEvent.data`) передаются от инициирующего события по ссылке

_Например_
```html
<div>
 <div>
  <e on="test" do="broadcastEvent">p,span</e>
  <!-- Этот обработчик будет вызван -->
  <p>
   <e on="test" do="something"></e>
   <!-- Этот обработчик будет вызван благодаря broadcastEvent -->
   Этот параграф содержит 
   <span>
    <e on="test" do="somethingElse"></e>
    <!-- И этот тоже -->
    span
   </span>
  </p>
 </div>
 <exec>
  <dispatch e="test" p="childNodes"></dispatch>
  <!-- Запускаем событие test только для дочерних элементов -->
 </exec>
</div>
```

##### Обработчик `dispatchEvent`

```html
<e on="eventName" do="dispatchEvent">dispatcherID[,executionMode]</e>
```
Где
* `dispatcherID` -- идентификатор ноды `<dispatch>`
* `executionMode` -- дополнительные режимы: `checkEmpty`, `useData` или `default`

Данный обработчик производит удаленный запуск диспатчера по его `dispatcherID`. По умолчанию используется режим `default`. 

В случае, если указан режим `checkEmpty`, запуск диспатчера выполняется только если нода обработчика не содержит значимого текстового контента (проверка выполняется по текстовому содержимому, при этом пробелы считаются "пустотой") 

Если указан режим `useData`, то диспатчер будет запускаться с переопределенными данными события (zEvent.data). Если этот параметр не указан, диспатчер будет использовать или свои данные, которые указаны в содержимом тега `<dispatch>`, или пустой объект.

_Например_
```html
<div>
 <div>
  <e on="test" do="dispatchEvent">coolDispatcher,useData</e>
  <!-- 2. Этот обработчик запустит диспатчер с id="coolDispatcher", и передаст ему данные { "x": 1 } -->
  <e on="doIt" do="something"></e>
  <!-- 4. Выполнится обработчик something -->
 </div>
 <exec>
  <dispatch e="test" p="childNodes">{ "x": 1 }</dispatch>
  <!-- 1. Запускаем событие test только для дочерних элементов -->
 </exec>
 <dispatch id="coolDispatcher" e="doIt">{ "x": 2 }</dispatch>
 <!-- 3. Запускаем событие doIt, данные события будут от 1-го диспатчера, а не текущего -->
</div>
```

---

### Темплейтирование
